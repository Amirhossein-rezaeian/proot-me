<?xml version="1.0" encoding="utf-8"?>
<!-- Generated by Docutils 0.16 -->
<document dupnames="proot" ids="proot" source="proot/manual.rst" title="PRoot"><title>PRoot</title><subtitle ids="chroot-mount-bind-and-binfmt-misc-without-privilege-setup" names="chroot,\ mount\ --bind,\ and\ binfmt_misc\ without\ privilege/setup"><literal>chroot</literal>, <literal>mount --bind</literal>, and <literal>binfmt_misc</literal> without privilege/setup</subtitle><docinfo><date>2020-04-14</date><version>5.2.0-alpha</version><field classes="manual-section"><field_name>Manual section</field_name><field_body><paragraph>1</paragraph></field_body></field></docinfo><section ids="synopsis" names="synopsis"><title>Synopsis</title><paragraph><strong>proot</strong> [<emphasis>option</emphasis>] ... [<emphasis>command</emphasis>]</paragraph></section><section ids="description" names="description"><title>Description</title><paragraph>PRoot is a user-space implementation of <literal>chroot</literal>, <literal>mount --bind</literal>,
and <literal>binfmt_misc</literal>.  This means that users don't need any privileges
or setup to do things like using an arbitrary directory as the new
root filesystem, making files accessible somewhere else in the
filesystem hierarchy, or executing programs built for another CPU
architecture transparently through QEMU user-mode.  Also, developers
can use PRoot as a generic Linux process instrumentation engine thanks
to its extension mechanism, see <reference name="CARE" refuri="https://proot-me.github.io/care">CARE</reference> for an example.  Technically
PRoot relies on <literal>ptrace</literal>, an unprivileged system-call available in
every Linux kernel.</paragraph><paragraph>The new root file-system, a.k.a <emphasis>guest rootfs</emphasis>, typically contains a
Linux distribution.  By default PRoot confines the execution of
programs to the guest rootfs only, however users can use the built-in
<emphasis>mount/bind</emphasis> mechanism to access files and directories from the actual
root file-system, a.k.a <emphasis>host rootfs</emphasis>, just as if they were part of
the guest rootfs.</paragraph><paragraph>When the guest Linux distribution is made for a CPU architecture
incompatible with the host one, PRoot uses the CPU emulator QEMU
user-mode to execute transparently guest programs.  It's a convenient
way to develop, to build, and to validate any guest Linux packages
seamlessly on users' computer, just as if they were in a <emphasis>native</emphasis>
guest environment.  That way all of the cross-compilation issues are
avoided.</paragraph><paragraph>PRoot can also <emphasis>mix</emphasis> the execution of host programs and the execution
of guest programs emulated by QEMU user-mode.  This is useful to use
host equivalents of programs that are missing from the guest rootfs
and to speed up build-time by using cross-compilation tools or
CPU-independent programs, like interpreters.</paragraph><paragraph>It is worth noting that the guest kernel is never involved, regardless
of whether QEMU user-mode is used or not.  Technically, when guest
programs perform access to system resources, PRoot translates their
requests before sending them to the host kernel.  This means that
guest programs can use host resources (devices, network, ...) just as
if they were "normal" host programs.</paragraph><target ids="care" names="care" refuri="https://proot-me.github.io/care"></target></section><section ids="options" names="options"><title>Options</title><paragraph>The command-line interface is composed of two parts: first PRoot's
options (optional), then the command to launch (<literal>/bin/sh</literal> if not
specified).  This section describes the options supported by PRoot,
that is, the first part of its command-line interface.</paragraph><section ids="regular-options" names="regular\ options"><title>Regular options</title><option_list><option_list_item><option_group><option><option_string>-r</option_string><option_argument delimiter=" ">path</option_argument></option><option><option_string>--rootfs</option_string><option_argument delimiter="=">path</option_argument></option></option_group><description><paragraph>Use <emphasis>path</emphasis> as the new guest root file-system, default is <literal>/</literal>.</paragraph><paragraph>The specified <emphasis>path</emphasis> typically contains a Linux distribution where
all new programs will be confined.  The default rootfs is <literal>/</literal>
when none is specified, this makes sense when the bind mechanism
is used to relocate host files and directories, see the <literal>-b</literal>
option and the <literal>Examples</literal> section for details.</paragraph><paragraph>It is recommended to use the <literal>-R</literal> or <literal>-S</literal> options instead.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-b</option_string><option_argument delimiter=" ">path</option_argument></option><option><option_string>--bind</option_string><option_argument delimiter="=">path</option_argument></option><option><option_string>-m</option_string><option_argument delimiter=" ">path</option_argument></option><option><option_string>--mount</option_string><option_argument delimiter="=">path</option_argument></option></option_group><description><paragraph>Make the content of <emphasis>path</emphasis> accessible in the guest rootfs.</paragraph><paragraph>This option makes any file or directory of the host rootfs
accessible in the confined environment just as if it were part of
the guest rootfs.  By default the host path is bound to the same
path in the guest rootfs but users can specify any other location
with the syntax: <literal>-b *host_path*:*guest_location*</literal>.  If the
guest location is a symbolic link, it is dereferenced to ensure
the new content is accessible through all the symbolic links that
point to the overlaid content.  In most cases this default
behavior shouldn't be a problem, although it is possible to
explicitly not dereference the guest location by appending it the
<literal>!</literal> character: <literal>-b *host_path*:*guest_location!*</literal>.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-q</option_string><option_argument delimiter=" ">command</option_argument></option><option><option_string>--qemu</option_string><option_argument delimiter="=">command</option_argument></option></option_group><description><paragraph>Execute guest programs through QEMU as specified by <emphasis>command</emphasis>.</paragraph><paragraph>Each time a guest program is going to be executed, PRoot inserts
the QEMU user-mode <emphasis>command</emphasis> in front of the initial request.
That way, guest programs actually run on a virtual guest CPU
emulated by QEMU user-mode.  The native execution of host programs
is still effective and the whole host rootfs is bound to
<literal>/host-rootfs</literal> in the guest environment.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-w</option_string><option_argument delimiter=" ">path</option_argument></option><option><option_string>--pwd</option_string><option_argument delimiter="=">path</option_argument></option><option><option_string>--cwd</option_string><option_argument delimiter="=">path</option_argument></option></option_group><description><paragraph>Set the initial working directory to <emphasis>path</emphasis>.</paragraph><paragraph>Some programs expect to be launched from a given directory but do
not perform any <literal>chdir</literal> by themselves.  This option avoids the
need for running a shell and then entering the directory manually.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-v</option_string><option_argument delimiter=" ">value</option_argument></option><option><option_string>--verbose</option_string><option_argument delimiter="=">value</option_argument></option></option_group><description><paragraph>Set the level of debug information to <emphasis>value</emphasis>.</paragraph><paragraph>The higher the integer <emphasis>value</emphasis> is, the more detailed debug
information is printed to the standard error stream.  A negative
<emphasis>value</emphasis> makes PRoot quiet except on fatal errors.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-V</option_string></option><option><option_string>--version</option_string></option><option><option_string>--about</option_string></option></option_group><description><paragraph>Print version, copyright, license and contact, then exit.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-h</option_string></option><option><option_string>--help</option_string></option><option><option_string>--usage</option_string></option></option_group><description><paragraph>Print the version and the command-line usage, then exit.</paragraph></description></option_list_item></option_list></section><section ids="extension-options" names="extension\ options"><title>Extension options</title><paragraph>The following options enable built-in extensions.  Technically
developers can add their own features to PRoot or use it as a Linux
process instrumentation engine thanks to its extension mechanism, see
the sources for further details.</paragraph><option_list><option_list_item><option_group><option><option_string>-k</option_string><option_argument delimiter=" ">string</option_argument></option><option><option_string>--kernel-release</option_string><option_argument delimiter="=">string</option_argument></option></option_group><description><paragraph>Make current kernel appear as kernel release <emphasis>string</emphasis>.</paragraph><paragraph>If a program is run on a kernel older than the one expected by its
GNU C library, the following error is reported: "FATAL: kernel too
old".  To be able to run such programs, PRoot can emulate some of
the features that are available in the kernel release specified by
<emphasis>string</emphasis> but that are missing in the current kernel.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-0</option_string></option><option><option_string>--root-id</option_string></option></option_group><description><paragraph>Make current user appear as "root" and fake its privileges.</paragraph><paragraph>Some programs will refuse to work if they are not run with "root"
privileges, even if there is no technical reason for that.  This
is typically the case with package managers.  This option allows
users to bypass this kind of limitation by faking the user/group
identity, and by faking the success of some operations like
changing the ownership of files, changing the root directory to
<literal>/</literal>, ...  Note that this option is quite limited compared to
<literal>fakeroot</literal>.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-i</option_string><option_argument delimiter=" ">string</option_argument></option><option><option_string>--change-id</option_string><option_argument delimiter="=">string</option_argument></option></option_group><description><paragraph>Make current user and group appear as <emphasis>string</emphasis> "uid:gid".</paragraph><paragraph>This option makes the current user and group appear as <emphasis>uid</emphasis> and
<emphasis>gid</emphasis>.  Likewise, files actually owned by the current user and
group appear as if they were owned by <emphasis>uid</emphasis> and <emphasis>gid</emphasis> instead.
Note that the <literal>-0</literal> option is the same as <literal>-i 0:0</literal>.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-p</option_string><option_argument delimiter=" ">string</option_argument></option><option><option_string>--port</option_string><option_argument delimiter="=">string</option_argument></option></option_group><description><paragraph>Map ports to others with the syntax as <emphasis>string</emphasis> "port_in:port_out ...".</paragraph><paragraph>This option makes PRoot intercept bind and connect system calls,
and change the port they use. The port map is specified
with the syntax: <literal>-b *port_in*:*port_out*</literal>. For example,
an application that runs a MySQL server binding to 5432 wants
to cohabit with other similar application, but doesn't have an
option to change its port. PRoot can be used here to modify
this port: <literal>proot -p 5432:5433 myapplication</literal>. With this command,
the MySQL server will be bound to the port 5433.
This command can be repeated multiple times to map multiple ports.</paragraph></description></option_list_item><option_list_item><option_group><option><option_string>-n</option_string></option><option><option_string>--netcoop</option_string></option></option_group><description><paragraph>Activates the network cooperation mode.</paragraph><paragraph>This option makes PRoot intercept bind() system calls and
change the port they are binding to to 0. With this, the system will
allocate an available port. Each time this is done, a new entry is added
to the port mapping entries, so that corresponding connect() system calls
use the same resulting port.</paragraph></description></option_list_item></option_list></section><section ids="alias-options" names="alias\ options"><title>Alias options</title><paragraph>The following options are aliases for handy sets of options.</paragraph><option_list><option_list_item><option_group><option><option_string>-R</option_string><option_argument delimiter=" ">path</option_argument></option></option_group><description><paragraph>Alias: <literal>-r *path*</literal> + a couple of recommended <literal>-b</literal>.</paragraph><paragraph>Programs isolated in <emphasis>path</emphasis>, a guest rootfs, might still need to
access information about the host system, as it is illustrated in
the <literal>Examples</literal> section of the manual.  These host information
are typically: user/group definition, network setup, run-time
information, users' files, ...  On all Linux distributions, they
all lie in a couple of host files and directories that are
automatically bound by this option:</paragraph><bullet_list bullet="*"><list_item><paragraph>/etc/host.conf</paragraph></list_item><list_item><paragraph>/etc/hosts</paragraph></list_item><list_item><paragraph>/etc/hosts.equiv</paragraph></list_item><list_item><paragraph>/etc/mtab</paragraph></list_item><list_item><paragraph>/etc/netgroup</paragraph></list_item><list_item><paragraph>/etc/networks</paragraph></list_item><list_item><paragraph>/etc/passwd</paragraph></list_item><list_item><paragraph>/etc/group</paragraph></list_item><list_item><paragraph>/etc/nsswitch.conf</paragraph></list_item><list_item><paragraph>/etc/resolv.conf</paragraph></list_item><list_item><paragraph>/etc/localtime</paragraph></list_item><list_item><paragraph>/dev/</paragraph></list_item><list_item><paragraph>/sys/</paragraph></list_item><list_item><paragraph>/proc/</paragraph></list_item><list_item><paragraph>/tmp/</paragraph></list_item><list_item><paragraph>/run/</paragraph></list_item><list_item><paragraph>/var/run/dbus/system_bus_socket</paragraph></list_item><list_item><paragraph>$HOME</paragraph></list_item><list_item><paragraph><emphasis>path</emphasis></paragraph></list_item></bullet_list></description></option_list_item><option_list_item><option_group><option><option_string>-S</option_string><option_argument delimiter=" ">path</option_argument></option></option_group><description><paragraph>Alias: <literal>-0 -r *path*</literal> + a couple of recommended <literal>-b</literal>.</paragraph><paragraph>This option is useful to safely create and install packages into
the guest rootfs.  It is similar to the <literal>-R</literal> option except it
enables the <literal>-0</literal> option and binds only the following minimal set
of paths to avoid unexpected changes on host files:</paragraph><bullet_list bullet="*"><list_item><paragraph>/etc/host.conf</paragraph></list_item><list_item><paragraph>/etc/hosts</paragraph></list_item><list_item><paragraph>/etc/nsswitch.conf</paragraph></list_item><list_item><paragraph>/etc/resolv.conf</paragraph></list_item><list_item><paragraph>/dev/</paragraph></list_item><list_item><paragraph>/sys/</paragraph></list_item><list_item><paragraph>/proc/</paragraph></list_item><list_item><paragraph>/tmp/</paragraph></list_item><list_item><paragraph>/run/shm</paragraph></list_item><list_item><paragraph>$HOME</paragraph></list_item><list_item><paragraph><emphasis>path</emphasis></paragraph></list_item></bullet_list></description></option_list_item></option_list></section></section><section ids="exit-status" names="exit\ status"><title>Exit Status</title><paragraph>If an internal error occurs, <literal>proot</literal> returns a non-zero exit status,
otherwise it returns the exit status of the last terminated
program. When an error has occurred, the only way to know if it comes
from the last terminated program or from <literal>proot</literal> itself is to have a
look at the error message.</paragraph></section><section ids="files" names="files"><title>Files</title><paragraph>PRoot reads links in <literal>/proc/&lt;pid&gt;/fd/</literal> to support <title_reference>openat(2)</title_reference>-like
syscalls made by the guest programs.</paragraph></section><section ids="examples" names="examples"><title>Examples</title><paragraph>In the following examples the directories <literal>/mnt/slackware-8.0</literal> and
<literal>/mnt/armslack-12.2/</literal> contain a Linux distribution respectively made
for x86 CPUs and ARM CPUs.</paragraph><section ids="chroot-equivalent" names="chroot\ equivalent"><title><literal>chroot</literal> equivalent</title><paragraph>To execute a command inside a given Linux distribution, just give
<literal>proot</literal> the path to the guest rootfs followed by the desired
command.  The example below executes the program <literal>cat</literal> to print the
content of a file:</paragraph><literal_block xml:space="preserve">proot -r /mnt/slackware-8.0/ cat /etc/motd

Welcome to Slackware Linux 8.0</literal_block><paragraph>The default command is <literal>/bin/sh</literal> when none is specified. Thus the
shortest way to confine an interactive shell and all its sub-programs
is:</paragraph><literal_block xml:space="preserve">proot -r /mnt/slackware-8.0/

$ cat /etc/motd
Welcome to Slackware Linux 8.0</literal_block></section><section ids="mount-bind-equivalent" names="mount\ --bind\ equivalent"><title><literal>mount --bind</literal> equivalent</title><paragraph>The bind mechanism enables one to relocate files and directories.  This is
typically useful to trick programs that perform access to hard-coded
locations, like some installation scripts:</paragraph><literal_block xml:space="preserve">proot -b /tmp/alternate_opt:/opt

$ cd to/sources
$ make install
[...]
install -m 755 prog "/opt/bin"
[...] # prog is installed in "/tmp/alternate_opt/bin" actually</literal_block><paragraph>As shown in this example, it is possible to bind over files not even
owned by the user.  This can be used to <emphasis>overlay</emphasis> system configuration
files, for instance the DNS setting:</paragraph><literal_block xml:space="preserve">ls -l /etc/hosts
-rw-r--r-- 1 root root 675 Mar  4  2011 /etc/hosts</literal_block><literal_block xml:space="preserve">proot -b ~/alternate_hosts:/etc/hosts

$ echo '1.2.3.4 google.com' &gt; /etc/hosts
$ resolveip google.com
IP address of google.com is 1.2.3.4
$ echo '5.6.7.8 google.com' &gt; /etc/hosts
$ resolveip google.com
IP address of google.com is 5.6.7.8</literal_block><paragraph>Another example: on most Linux distributions <literal>/bin/sh</literal> is a symbolic
link to <literal>/bin/bash</literal>, whereas it points to <literal>/bin/dash</literal> on Debian
and Ubuntu.  As a consequence a <literal>#!/bin/sh</literal> script tested with Bash
might not work with Dash.  In this case, the binding mechanism of
PRoot can be used to set non-disruptively <literal>/bin/bash</literal> as the default
<literal>/bin/sh</literal> on these two Linux distributions:</paragraph><literal_block xml:space="preserve">proot -b /bin/bash:/bin/sh [...]</literal_block><paragraph>Because <literal>/bin/sh</literal> is initially a symbolic link to <literal>/bin/dash</literal>, the
content of <literal>/bin/bash</literal> is actually bound over this latter:</paragraph><literal_block xml:space="preserve">proot -b /bin/bash:/bin/sh

$ md5sum /bin/sh
089ed56cd74e63f461bef0fdfc2d159a  /bin/sh
$ md5sum /bin/bash
089ed56cd74e63f461bef0fdfc2d159a  /bin/bash
$ md5sum /bin/dash
089ed56cd74e63f461bef0fdfc2d159a  /bin/dash</literal_block><paragraph>In most cases this shouldn't be a problem, but it is still possible to
strictly bind <literal>/bin/bash</literal> over <literal>/bin/sh</literal> -- without dereferencing
it -- by specifying the <literal>!</literal> character at the end:</paragraph><literal_block xml:space="preserve">proot -b '/bin/bash:/bin/sh!'

$ md5sum /bin/sh
089ed56cd74e63f461bef0fdfc2d159a  /bin/sh
$ md5sum /bin/bash
089ed56cd74e63f461bef0fdfc2d159a  /bin/bash
$ md5sum /bin/dash
c229085928dc19e8d9bd29fe88268504  /bin/dash</literal_block></section><section ids="chroot-mount-bind-equivalent" names="chroot\ +\ mount\ --bind\ equivalent"><title><literal>chroot</literal> + <literal>mount --bind</literal> equivalent</title><paragraph>The two features above can be combined to make any file from the host
rootfs accessible in the confined environment just as if it were
initially part of the guest rootfs.  It is sometimes required to run
programs that rely on some specific files:</paragraph><literal_block xml:space="preserve">proot -r /mnt/slackware-8.0/

$ ps -o tty,command
Error, do this: mount -t proc none /proc</literal_block><paragraph>works better with:</paragraph><literal_block xml:space="preserve">proot -r /mnt/slackware-8.0/ -b /proc

$ ps -o tty,command
TT       COMMAND
?        bash
?        proot -b /proc /mnt/slackware-8.0/
?        sh
?        ps -o tty,command</literal_block><paragraph>Actually there's a bunch of such specific files, that's why PRoot
provides the option <literal>-R</literal> to bind automatically a pre-defined list of
recommended paths:</paragraph><literal_block xml:space="preserve">proot -R /mnt/slackware-8.0/

$ ps -o tty,command
TT       COMMAND
pts/6    bash
pts/6    proot -R /mnt/slackware-8.0/
pts/6    sh
pts/6    ps -o tty,command</literal_block></section><section ids="chroot-mount-bind-su-equivalent" names="chroot\ +\ mount\ --bind\ +\ su\ equivalent"><title><literal>chroot</literal> + <literal>mount --bind</literal> + <literal>su</literal> equivalent</title><paragraph>Some programs will not work correctly if they are not run by the
"root" user, this is typically the case with package managers.  PRoot
can fake the root identity and its privileges when the <literal>-0</literal> (zero)
option is specified:</paragraph><literal_block xml:space="preserve">proot -r /mnt/slackware-8.0/ -0

# id
uid=0(root) gid=0(root) [...]

# mkdir /tmp/foo
# chmod a-rwx /tmp/foo
# echo 'I bypass file-system permissions.' &gt; /tmp/foo/bar
# cat /tmp/foo/bar
I bypass file-system permissions.</literal_block><paragraph>This option is typically required to create or install packages into
the guest rootfs.  Note it is <emphasis>not</emphasis> recommended to use the <literal>-R</literal>
option when installing packages since they may try to update bound
system files, like <literal>/etc/group</literal>.  Instead, it is recommended to use
the <literal>-S</literal> option.  This latter enables the <literal>-0</literal> option and binds
only paths that are known to not be updated by packages:</paragraph><literal_block xml:space="preserve">proot -S /mnt/slackware-8.0/

# installpkg perl.tgz
Installing package perl...</literal_block></section><section ids="chroot-mount-bind-binfmt-misc-equivalent" names="chroot\ +\ mount\ --bind\ +\ binfmt_misc\ equivalent"><title><literal>chroot</literal> + <literal>mount --bind</literal> + <literal>binfmt_misc</literal> equivalent</title><paragraph>PRoot uses QEMU user-mode to execute programs built for a CPU
architecture incompatible with the host one.  From users'
point-of-view, guest programs handled by QEMU user-mode are executed
transparently, that is, just like host programs.  To enable this
feature users just have to specify which instance of QEMU user-mode
they want to use with the option <literal>-q</literal>:</paragraph><literal_block xml:space="preserve">proot -R /mnt/armslack-12.2/ -q qemu-arm

$ cat /etc/motd
Welcome to ARMedSlack Linux 12.2</literal_block><paragraph>The parameter of the <literal>-q</literal> option is actually a whole QEMU user-mode
command, for instance to enable its GDB server on port 1234:</paragraph><literal_block xml:space="preserve">proot -R /mnt/armslack-12.2/ -q "qemu-arm -g 1234" emacs</literal_block><paragraph>PRoot allows one to mix transparently the emulated execution of guest
programs and the native execution of host programs in the same
file-system namespace.  It's typically useful to extend the list of
available programs and to speed up build-time significantly.  This
mixed-execution feature is enabled by default when using QEMU
user-mode, and the content of the host rootfs is made accessible
through <literal>/host-rootfs</literal>:</paragraph><literal_block xml:space="preserve">proot -R /mnt/armslack-12.2/ -q qemu-arm

$ file /bin/echo
[...] ELF 32-bit LSB executable, ARM [...]
$ /bin/echo 'Hello world!'
Hello world!

$ file /host-rootfs/bin/echo
[...] ELF 64-bit LSB executable, x86-64 [...]
$ /host-rootfs/bin/echo 'Hello mixed world!'
Hello mixed world!</literal_block><paragraph>Since both host and guest programs use the guest rootfs as <literal>/</literal>,
users may want to deactivate explicitly cross-filesystem support found
in most GNU cross-compilation tools.  For example with GCC configured
to cross-compile to the ARM target:</paragraph><literal_block xml:space="preserve">proot -R /mnt/armslack-12.2/ -q qemu-arm

$ export CC=/host-rootfs/opt/cross-tools/arm-linux/bin/gcc
$ export CFLAGS="--sysroot=/"   # could be optional indeed
$ ./configure; make</literal_block><paragraph>As with regular files, a host instance of a program can be bound over
its guest instance.  Here is an example where the guest binary of
<literal>make</literal> is overlaid by the host one:</paragraph><literal_block xml:space="preserve">proot -R /mnt/armslack-12.2/ -q qemu-arm -b /usr/bin/make

$ which make
/usr/bin/make
$ make --version # overlaid
GNU Make 3.82
Built for x86_64-slackware-linux-gnu</literal_block><paragraph>It's worth mentioning that even when mixing the native execution of
host programs and the emulated execution of guest programs, they still
believe they are running in a native guest environment.  As a
demonstration, here is a partial output of a typical <literal>./configure</literal>
script:</paragraph><literal_block xml:space="preserve">checking whether the C compiler is a cross-compiler... no</literal_block></section></section><section ids="downloads" names="downloads"><title>Downloads</title><section dupnames="proot" ids="id1"><title>PRoot</title><paragraph>The source code for PRoot and CARE are hosted in the same repository on <reference name="GitHub" refuri="https://github.com/proot-me/proot">GitHub</reference><target ids="github" names="github" refuri="https://github.com/proot-me/proot"></target>.
Previous PRoot releases were packaged at <reference refuri="https://github.com/proot-me/proot-static-build/releases">https://github.com/proot-me/proot-static-build/releases</reference>, however, that
repository has since been archived. The latest builds can be found under the job artifacts for the <reference name="GitLab CI/CD Pipelines" refuri="https://gitlab.com/proot/proot/pipelines">GitLab CI/CD Pipelines</reference><target ids="gitlab-ci-cd-pipelines" names="gitlab\ ci/cd\ pipelines" refuri="https://gitlab.com/proot/proot/pipelines"></target> for each commit.</paragraph></section><section ids="rootfs" names="rootfs"><title>Rootfs</title><paragraph>Here follows a couple of URLs where some rootfs archives can be freely
downloaded.  Note that <literal>mknod</literal> errors reported by <literal>tar</literal> when
extracting these archives can be safely ignored since special files
are typically bound (see <literal>-R</literal> option for details).</paragraph><bullet_list bullet="*"><list_item><paragraph><reference refuri="https://download.openvz.org/template/precreated">https://download.openvz.org/template/precreated</reference></paragraph></list_item><list_item><paragraph><reference refuri="https://images.linuxcontainers.org/images">https://images.linuxcontainers.org/images</reference></paragraph></list_item><list_item><paragraph><reference refuri="http://distfiles.gentoo.org/releases">http://distfiles.gentoo.org/releases</reference></paragraph></list_item><list_item><paragraph><reference refuri="http://cdimage.ubuntu.com/ubuntu-core">http://cdimage.ubuntu.com/ubuntu-core</reference></paragraph></list_item><list_item><paragraph><reference refuri="https://archlinuxarm.org/about/downloads">https://archlinuxarm.org/about/downloads</reference></paragraph></list_item><list_item><paragraph><reference refuri="https://alpinelinux.org/downloads">https://alpinelinux.org/downloads</reference></paragraph></list_item></bullet_list><paragraph>Technically such rootfs archive can be created by running the
following command on the expected Linux distribution:</paragraph><literal_block xml:space="preserve">tar --one-file-system --create --gzip --file my_rootfs.tar.gz /</literal_block></section></section><section ids="ecosystem" names="ecosystem"><title>Ecosystem</title><paragraph>The following ecosystem has developed around PRoot since it has been
made publicly available.</paragraph><section ids="projects-using-proot-or-care" names="projects\ using\ proot\ or\ care"><title>Projects using PRoot or CARE</title><bullet_list bullet="*"><list_item><paragraph><reference name="ATOS" refuri="http://compilfr.ens-lyon.fr/wp-content/uploads/2013/12/17-Francois_DeFerriere.pdf">ATOS</reference><target ids="atos" names="atos" refuri="http://compilfr.ens-lyon.fr/wp-content/uploads/2013/12/17-Francois_DeFerriere.pdf"></target>:
find automatically C/C++ compiler options that provide best
optimizations.</paragraph></list_item><list_item><paragraph><reference name="CARE" refuri="https://proot-me.github.io/care">CARE</reference>: archive material used during an execution to make it
reproducible on any Linux system.</paragraph></list_item><list_item><paragraph><reference name="Debian noroot" refuri="https://play.google.com/store/apps/details?id=com.cuntubuntu">Debian noroot</reference><target ids="debian-noroot" names="debian\ noroot" refuri="https://play.google.com/store/apps/details?id=com.cuntubuntu"></target>:
use Debian Linux on Android without root access.</paragraph></list_item><list_item><paragraph><reference name="GNURoot" refuri="https://play.google.com/store/apps/details?id=champion.gnuroot">GNURoot</reference><target ids="gnuroot" names="gnuroot" refuri="https://play.google.com/store/apps/details?id=champion.gnuroot"></target>:
use several Linux distros on Android without root access.</paragraph></list_item><list_item><paragraph><reference name="JuNest" refuri="http://fsquillace.github.io/junest-site">JuNest</reference><target ids="junest" names="junest" refuri="http://fsquillace.github.io/junest-site"></target>:
use Arch Linux on any Linux distros without root access.</paragraph></list_item><list_item><paragraph><reference name="OPAM2Debian" refuri="https://forge.ocamlcore.org/projects/opam2debian">OPAM2Debian</reference><target ids="opam2debian" names="opam2debian" refuri="https://forge.ocamlcore.org/projects/opam2debian"></target>:
create Debian packages which contains a fully compiled OPAM
installation.</paragraph></list_item><list_item><paragraph><reference name="OpenMOLE" refuri="https://www.openmole.org">OpenMOLE</reference><target ids="openmole" names="openmole" refuri="https://www.openmole.org"></target>:
execute programs on distributed computing environments.</paragraph></list_item><list_item><paragraph><reference name="Polysquare Travis Container" refuri="https://github.com/polysquare/polysquare-travis-container">Polysquare Travis Container</reference><target ids="polysquare-travis-container" names="polysquare\ travis\ container" refuri="https://github.com/polysquare/polysquare-travis-container"></target>:
use several Linux distros on Travis-CI without root access.</paragraph></list_item><list_item><paragraph><reference name="Portable PyPy" refuri="https://github.com/squeaky-pl/portable-pypy">Portable PyPy</reference><target ids="portable-pypy" names="portable\ pypy" refuri="https://github.com/squeaky-pl/portable-pypy"></target>:
portable 32 and 64 bit x86 PyPy binaries.</paragraph></list_item><list_item><paragraph><reference name="SIO Workers" refuri="http://sioworkers.readthedocs.org/en/latest">SIO Workers</reference><target ids="sio-workers" names="sio\ workers" refuri="http://sioworkers.readthedocs.org/en/latest"></target>:
batch long-term computations with Python.</paragraph></list_item></bullet_list></section><section ids="third-party-packages" names="third\ party\ packages"><title>Third party packages</title><paragraph>Binaries from the <reference name="Downloads" refid="downloads">Downloads</reference> section are likely more up-to-date.</paragraph><bullet_list bullet="*"><list_item><paragraph><reference name="Alpine Linux" refuri="https://pkgs.alpinelinux.org/packages?name=proot">Alpine Linux</reference><target ids="alpine-linux" names="alpine\ linux" refuri="https://pkgs.alpinelinux.org/packages?name=proot"></target></paragraph></list_item><list_item><paragraph><reference name="Arch Linux" refuri="https://aur.archlinux.org/packages/proot">Arch Linux</reference><target ids="arch-linux" names="arch\ linux" refuri="https://aur.archlinux.org/packages/proot"></target></paragraph></list_item><list_item><paragraph><reference name="Debian" refuri="https://packages.debian.org/sid/proot">Debian</reference><target ids="debian" names="debian" refuri="https://packages.debian.org/sid/proot"></target></paragraph></list_item><list_item><paragraph><reference name="Gentoo" refuri="http://packages.gentoo.org/package/sys-apps/proot">Gentoo</reference><target ids="gentoo" names="gentoo" refuri="http://packages.gentoo.org/package/sys-apps/proot"></target></paragraph></list_item><list_item><paragraph><reference name="NixOS" refuri="https://github.com/NixOS/nixpkgs/tree/master/pkgs/tools/system/proot">NixOS</reference><target ids="nixos" names="nixos" refuri="https://github.com/NixOS/nixpkgs/tree/master/pkgs/tools/system/proot"></target></paragraph></list_item><list_item><paragraph><reference name="Termux" refuri="https://wiki.termux.com/wiki/PRoot">Termux</reference><target ids="termux" names="termux" refuri="https://wiki.termux.com/wiki/PRoot"></target></paragraph></list_item><list_item><paragraph><reference name="Ubuntu" refuri="https://launchpad.net/ubuntu/+source/proot">Ubuntu</reference><target ids="ubuntu" names="ubuntu" refuri="https://launchpad.net/ubuntu/+source/proot"></target></paragraph></list_item><list_item><paragraph><reference name="University of Chicago RCC" refuri="https://rcc.uchicago.edu/docs/software/modules/proot/midway2/current.html">University of Chicago RCC</reference><target ids="university-of-chicago-rcc" names="university\ of\ chicago\ rcc" refuri="https://rcc.uchicago.edu/docs/software/modules/proot/midway2/current.html"></target></paragraph></list_item><list_item><paragraph><reference name="Void Linux" refuri="https://github.com/void-linux/void-packages/tree/master/srcpkgs/proot">Void Linux</reference><target ids="void-linux" names="void\ linux" refuri="https://github.com/void-linux/void-packages/tree/master/srcpkgs/proot"></target></paragraph></list_item></bullet_list></section><section ids="public-material-about-proot-or-care" names="public\ material\ about\ proot\ or\ care"><title>Public material about PRoot or CARE</title><bullet_list bullet="*"><list_item><paragraph>articles on <reference name="Rémi's blog" refuri="https://blog.duraffort.fr/tag/proot.html">Rémi's blog</reference><target ids="remi-s-blog" names="rémi's\ blog" refuri="https://blog.duraffort.fr/tag/proot.html"></target>.  Rémi (a.k.a Ivoire)
is one of the PRoot developers.</paragraph></list_item><list_item><paragraph>presentation "<reference name="Software engineering tools based on syscall instrumentation" refuri="https://archive.fosdem.org/2014/schedule/event/syscall">Software engineering tools based on syscall
instrumentation</reference><target ids="software-engineering-tools-based-on-syscall-instrumentation" names="software\ engineering\ tools\ based\ on\ syscall\ instrumentation" refuri="https://archive.fosdem.org/2014/schedule/event/syscall"></target>" during
FOSDEM 2014.</paragraph></list_item><list_item><paragraph>presentation "<reference name="SW testing &amp; Reproducing a LAVA failures locally using CARE" refuri="https://connect.linaro.org/resources/lcu14/lcu14-211-lava-use-cases-sw-testing-reproducing-a-lava-failures-locally-using-care">SW testing &amp; Reproducing a LAVA failures locally
using CARE</reference><target ids="sw-testing-reproducing-a-lava-failures-locally-using-care" names="sw\ testing\ &amp;\ reproducing\ a\ lava\ failures\ locally\ using\ care" refuri="https://connect.linaro.org/resources/lcu14/lcu14-211-lava-use-cases-sw-testing-reproducing-a-lava-failures-locally-using-care"></target>"
during Linaro Connect USA 2014</paragraph></list_item><list_item><paragraph>presentation and essay "<reference name="CARE: the Comprehensive Archiver for Reproducible Execution" refuri="http://c-mind.org/events/trust2014/presentations/trust14_care.pdf">CARE: the Comprehensive Archiver for
Reproducible Execution</reference><target ids="care-the-comprehensive-archiver-for-reproducible-execution" names="care:\ the\ comprehensive\ archiver\ for\ reproducible\ execution" refuri="http://c-mind.org/events/trust2014/presentations/trust14_care.pdf"></target>"
(<reference name="essay" refuri="http://dl.acm.org/citation.cfm?doid=2618137.2618138">essay</reference><target ids="essay" names="essay" refuri="http://dl.acm.org/citation.cfm?doid=2618137.2618138"></target>)
during TRUST 2014</paragraph></list_item><list_item><paragraph>presentation "<reference name="An Introduction to the CARE tool (dead link)" refuri="#">An Introduction to the CARE tool (dead link)</reference><target ids="an-introduction-to-the-care-tool-dead-link" names="an\ introduction\ to\ the\ care\ tool\ (dead\ link)" refuri="#"></target>"
during HiPEAC CSW 2013</paragraph></list_item><list_item><paragraph>presentation and essay "<reference name="PRoot: a Step Forward for QEMU User-Mode" refuri="http://adt.cs.upb.de/quf/quf11/quf2011_13.pdf">PRoot: a Step Forward for QEMU User-Mode</reference><target ids="proot-a-step-forward-for-qemu-user-mode" names="proot:\ a\ step\ forward\ for\ qemu\ user-mode" refuri="http://adt.cs.upb.de/quf/quf11/quf2011_13.pdf"></target>" (<reference name="proceedings" refuri="http://adt.cs.upb.de/quf/quf2011_proceedings.pdf">proceedings</reference><target ids="proceedings" names="proceedings" refuri="http://adt.cs.upb.de/quf/quf2011_proceedings.pdf"></target>) during
QUF'11</paragraph></list_item><list_item><paragraph>tutorial "<reference name="How to install nix in home (on another distribution)" refuri="https://nixos.wiki/wiki/Nix_Installation_Guide#PRoot">How to install nix in home (on another distribution)</reference><target ids="how-to-install-nix-in-home-on-another-distribution" names="how\ to\ install\ nix\ in\ home\ (on\ another\ distribution)" refuri="https://nixos.wiki/wiki/Nix_Installation_Guide#PRoot"></target>"</paragraph></list_item></bullet_list></section><section ids="companies-using-proot-or-care-internally" names="companies\ using\ proot\ or\ care\ internally"><title>Companies using PRoot or CARE internally</title><bullet_list bullet="*"><list_item><paragraph>STMicroelectronics</paragraph></list_item><list_item><paragraph>Sony</paragraph></list_item><list_item><paragraph>Ericsson</paragraph></list_item><list_item><paragraph>Cisco</paragraph></list_item><list_item><paragraph>Gogo</paragraph></list_item><list_item><paragraph>Infinite Omicron, LLC.</paragraph></list_item></bullet_list></section></section><section ids="see-also" names="see\ also"><title>See Also</title><paragraph>chroot(1), mount(8), binfmt_misc, ptrace(2), qemu(1), sb2(1),
bindfs(1), fakeroot(1), fakechroot(1)</paragraph></section><section ids="colophon" names="colophon"><title>Colophon</title><paragraph>Visit <reference refuri="https://proot-me.github.io">https://proot-me.github.io</reference> for help, bug reports, suggestions, patches, ...
Copyright (C) 2020 PRoot Developers, licensed under GPL v2 or later.</paragraph><literal_block xml:space="preserve"> _____ _____              ___
|  __ \  __ \_____  _____|   |_
|   __/     /  _  \/  _  \    _|
|__|  |__|__\_____/\_____/\____|</literal_block></section></document>